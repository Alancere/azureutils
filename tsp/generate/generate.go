package generate

import (
	"errors"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/Masterminds/semver/v3"
)

// generate go sdk from typespec
// ### dev branch: typespec_project_script_0612
func generate() {
	// generate release-v2 args --TyepSpec
}

// 仿照 generator tool GenerateContext.GenerateForSingleRPNamespace
func generateSingleServe() (any, error) {
	packagePath := ""
	_ = packagePath
	changelogPath := ""

	// 默认版本号 v0.1.0
	version, err := semver.NewVersion("0.1.0")
	if err != nil {
		return nil, err
	}
	_ = version
	// 是否指定了release的版本号，指定版本号是生成sdk后替换还是使用此版本号用于生成sdk？（应该用指定version用于生成sdk，并且再根据此确定isCurrentPreview）
	// if generateParam.SpecficVersion != "" {
	// 	log.Printf("Use specfic version: %s", generateParam.SpecficVersion)
	// 	version, err = semver.NewVersion(generateParam.SpecficVersion)
	// 	if err != nil {
	// 		return nil, err
	// 	}
	// }

	onBoard := false // 是否还未releas过
	_ = onBoard
	if _, err := os.Stat(changelogPath); os.IsNotExist(err) { // 通过判断是否存在CHANGELOG.md来确定是否是OnBoard的
		onBoard = true

		// parse templates
	} else {
		// 移除AutoGenerated SDK code
		// log.Printf("Package '%s' existed, do update process", packagePath)

		// log.Printf("Remove all the generated files ...")
		// if err = CleanSDKGeneratedFiles(packagePath); err != nil {
		// 	return nil, err
		// }
	}

	// update azure-rest-api-specs commit id

	// specfic tag or use default tag(version)

	// 确定下一个release的版本号(根据上面的tag确认和specfic version确定?)

	// generate sdk code(是否生成examples之类的也在这里生成吗，还是像原先那样分开执行？)

	// 对比前后两版本生成changelog

	// 过滤changelog

	{ // onboard
		// 确认 pull request labels 和 使用正确的 first version
		// onboard 的 changelog(UpdateOnboardChangelogVersion) // 完全没必要
	}
	{ // !onBoard
		// 写changelog(AddChangelogToFile)

		/*
			有breakingchange并造成major 升级的，没法一开始就确定版本号(排除指定版本)
			根据最新计算出的版本号 regenerate sdk code？？？
		*/

		// 更新 README.md module (replaceReadmeModule) 和 其中的NewClient function

		// 更新live test中依赖的module
	}

	return nil, nil
}

// 解析 tspconfig.yaml
// 提供两种路径(local or http path)
func ParsePath(tspConfigPath string) (data []byte, err error) {
	data = make([]byte, 0, 1024)
	// 判断路径类型
	if strings.HasPrefix(tspConfigPath, "http") {
		// http path
		resp, err := http.Get(tspConfigPath)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()

		// 读取resp body数据
		data, err = io.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}
	} else {
		// local path
		data, err = os.ReadFile(tspConfigPath)
		if err != nil {
			return nil, err
		}
	}

	return
}

// 判断是否为preview版本
// 通过读取tspSpecPath文件下的所有.tsp文件，判断是否有preview版本
// 有则返回true，否则返回false
func currentTSPIsPreview(tspSpecPath string) (bool, error) {
	isPreview := false
	err := filepath.Walk(tspSpecPath, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if strings.HasSuffix(info.Name(), ".tsp") {
			data, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			// if strings.Contains(string(data), "preview") {}
			// 需要确认怎么从tsp中确定要release的版本
			if strings.Contains(string(data), "enum Versions {") {
				lines := strings.Split(string(data), "\n")
				for i, line := range lines {
					if line == "}" {
						if strings.Contains(lines[i-1], "preview") {
							isPreview = true
							return filepath.SkipAll
						}
					}
				}

			}
		}

		return nil
	})
	if err != nil && !errors.Is(err, filepath.SkipDir) {
		return false, err
	}

	return isPreview, nil
}
